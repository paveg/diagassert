package formatter

import (
	"strings"
	"testing"

	"github.com/paveg/diagassert/internal/evaluator"
)

func TestVisualLayerArchitecture_CreateVisualNodes(t *testing.T) {
	formatter := NewVisualFormatter()
	
	positions := []ValuePosition{
		{Expression: "x", Value: "10", VisualPos: 0, Priority: 20, Depth: 0},
		{Expression: ">", Value: "false", VisualPos: 2, Priority: 5, Depth: 1},
		{Expression: "20", Value: "20", VisualPos: 4, Priority: 15, Depth: 0},
	}
	
	nodes := formatter.createVisualNodes(positions)
	
	if len(nodes) != 3 {
		t.Errorf("Expected 3 nodes, got %d", len(nodes))
	}
	
	// Check that pipe positions are set correctly
	expectedPipePositions := []int{0, 2, 4}
	for i, node := range nodes {
		if node.PipePosition != expectedPipePositions[i] {
			t.Errorf("Node %d: expected pipe position %d, got %d", i, expectedPipePositions[i], node.PipePosition)
		}
		if node.VisualLayer != -1 {
			t.Errorf("Node %d: expected unassigned visual layer (-1), got %d", i, node.VisualLayer)
		}
	}
}

func TestVisualLayerArchitecture_ConflictDetection(t *testing.T) {
	formatter := NewVisualFormatter()
	
	// Create nodes that would overlap
	nodes := []VisualNode{
		{Position: ValuePosition{Value: "longvalue", VisualPos: 0}, PipePosition: 0},
		{Position: ValuePosition{Value: "10", VisualPos: 5}, PipePosition: 5}, // Would overlap with "longvalue"
		{Position: ValuePosition{Value: "20", VisualPos: 15}, PipePosition: 15}, // No overlap
	}
	
	conflictMap := formatter.detectConflicts(nodes)
	
	// Nodes 0 and 1 should conflict, but node 2 should not conflict with anyone
	if len(conflictMap.Conflicts[0]) != 1 || conflictMap.Conflicts[0][0] != 1 {
		t.Errorf("Expected node 0 to conflict with node 1, got conflicts: %v", conflictMap.Conflicts[0])
	}
	if len(conflictMap.Conflicts[1]) != 1 || conflictMap.Conflicts[1][0] != 0 {
		t.Errorf("Expected node 1 to conflict with node 0, got conflicts: %v", conflictMap.Conflicts[1])
	}
	if len(conflictMap.Conflicts[2]) != 0 {
		t.Errorf("Expected node 2 to have no conflicts, got conflicts: %v", conflictMap.Conflicts[2])
	}
}

func TestVisualLayerArchitecture_LayerAssignment(t *testing.T) {
	formatter := NewVisualFormatter()
	
	// Create nodes where some conflict and need different layers
	nodes := []VisualNode{
		{Position: ValuePosition{Value: "value1", VisualPos: 0, Priority: 20}, PipePosition: 0},
		{Position: ValuePosition{Value: "val2", VisualPos: 3, Priority: 15}, PipePosition: 3}, // Overlaps with value1
		{Position: ValuePosition{Value: "v3", VisualPos: 10, Priority: 10}, PipePosition: 10}, // No overlap
	}
	
	// Convert nodes back to positions for the new API
	positions := make([]ValuePosition, len(nodes))
	for i, node := range nodes {
		positions[i] = node.Position
	}
	
	assignment := formatter.assignVisualLayers(positions)
	
	// Check that conflicting nodes are assigned to different layers
	layer0Count := len(assignment.Layers[0])
	layer1Count := 0
	if len(assignment.Layers) > 1 {
		layer1Count = len(assignment.Layers[1])
	}
	
	// We should have nodes distributed across layers to avoid conflicts
	if layer0Count+layer1Count != 3 {
		t.Errorf("Expected all 3 nodes to be assigned, got %d in layer 0 and %d in layer 1", layer0Count, layer1Count)
	}
	
	// Non-conflicting node should be on layer 0, conflicting nodes should be separated
	if assignment.MaxLayer < 0 {
		t.Error("Expected at least one layer to be assigned")
	}
}

func TestVisualLayerArchitecture_FixedPipePositions(t *testing.T) {
	formatter := NewVisualFormatter()
	
	// Test that pipes stay fixed regardless of value conflicts
	positions := []ValuePosition{
		{Expression: "x", Value: "verylongvalue", VisualPos: 0, Priority: 20, Depth: 0},
		{Expression: "y", Value: "10", VisualPos: 2, Priority: 15, Depth: 0}, // Would overlap with verylongvalue
	}
	
	result := formatter.buildPowerAssertTreeWithLayers("x > y", positions)
	
	// Check that we have pipe and value lines
	if len(result) < 2 {
		t.Fatalf("Expected at least 2 lines (pipe + value), got %d: %v", len(result), result)
	}
	
	// Find pipe lines (contain '|')
	var pipeLines []string
	for _, line := range result {
		if strings.Contains(line, "|") {
			pipeLines = append(pipeLines, line)
		}
	}
	
	if len(pipeLines) == 0 {
		t.Error("Expected at least one pipe line")
	}
	
	// Check that pipes are at the expected positions (0 and 2)
	foundPosition0 := false
	foundPosition2 := false
	
	for _, pipeLine := range pipeLines {
		if len(pipeLine) > 0 && pipeLine[0] == '|' {
			foundPosition0 = true
		}
		if len(pipeLine) > 2 && pipeLine[2] == '|' {
			foundPosition2 = true
		}
	}
	
	if !foundPosition0 {
		t.Errorf("Expected pipe at position 0 in at least one pipe line. Lines: %v", pipeLines)
	}
	if !foundPosition2 {
		t.Errorf("Expected pipe at position 2 in at least one pipe line. Lines: %v", pipeLines)
	}
}

func TestVisualLayerArchitecture_ValueAlignment(t *testing.T) {
	formatter := NewVisualFormatter()
	
	// Test that values are aligned with their pipes, not shifted for centering
	positions := []ValuePosition{
		{Expression: "x", Value: "15", VisualPos: 0, Priority: 20, Depth: 0},
		{Expression: ">", Value: "false", VisualPos: 2, Priority: 5, Depth: 1},
	}
	
	result := formatter.buildPowerAssertTreeWithLayers("x > 20", positions)
	
	// Find value lines (don't contain '|' but contain numbers/text)
	var valueLines []string
	for _, line := range result {
		if !strings.Contains(line, "|") && strings.TrimSpace(line) != "" {
			valueLines = append(valueLines, line)
		}
	}
	
	if len(valueLines) == 0 {
		t.Fatal("Expected at least one value line")
	}
	
	// Check that "15" appears at position 0 (aligned with pipe)
	found15 := false
	foundFalse := false
	for _, valueLine := range valueLines {
		if len(valueLine) >= 2 && strings.HasPrefix(valueLine, "15") {
			found15 = true
		}
		if strings.Contains(valueLine, "false") {
			// false should appear at position 2 (aligned with > operator)
			falsePos := strings.Index(valueLine, "false")
			if falsePos == 2 {
				foundFalse = true
			}
		}
	}
	
	if !found15 {
		t.Errorf("Expected '15' to be aligned at position 0, value lines: %v", valueLines)
	}
	if !foundFalse {
		t.Errorf("Expected 'false' to be aligned at position 2, value lines: %v", valueLines)
	}
}

func TestVisualLayerArchitecture_ComplexExpression(t *testing.T) {
	formatter := NewVisualFormatter()
	
	// Test with a more complex expression that has multiple potential conflicts
	result := &evaluator.ExpressionResult{
		Expression: "age >= 18 && hasLicense",
		Result:     false,
		Variables: map[string]interface{}{
			"age":        16,
			"hasLicense": false,
		},
		Tree: &evaluator.EvaluationTree{
			ID:       1,
			Type:     "logical",
			Operator: "&&",
			Text:     "age >= 18 && hasLicense",
			Result:   false,
			Left: &evaluator.EvaluationTree{
				ID:       2,
				Type:     "comparison",
				Operator: ">=",
				Text:     "age >= 18",
				Result:   false,
				Left: &evaluator.EvaluationTree{
					ID:    3,
					Type:  "identifier",
					Text:  "age",
					Value: 16,
				},
				Right: &evaluator.EvaluationTree{
					ID:    4,
					Type:  "literal",
					Text:  "18",
					Value: 18,
				},
			},
			Right: &evaluator.EvaluationTree{
				ID:     5,
				Type:   "identifier",
				Text:   "hasLicense",
				Value:  false,
				Result: false,
			},
		},
	}
	
	output := formatter.FormatVisual(result, "test.go", 1, "")
	
	// Check that the output contains the expected elements
	expectedElements := []string{
		"assert(age >= 18 && hasLicense)",
		"16",     // age value
		"18",     // literal value
		"false",  // hasLicense value and results
	}
	
	for _, element := range expectedElements {
		if !strings.Contains(output, element) {
			t.Errorf("Expected output to contain %q, but it didn't.\nOutput:\n%s", element, output)
		}
	}
	
	// Check that we have a reasonable structure (pipes and values)
	lines := strings.Split(output, "\n")
	hasAssertLine := false
	hasPipes := false
	hasValues := false
	
	for _, line := range lines {
		if strings.Contains(line, "assert(") {
			hasAssertLine = true
		}
		if strings.Contains(line, "|") {
			hasPipes = true
		}
		if strings.Contains(line, "16") || strings.Contains(line, "18") {
			hasValues = true
		}
	}
	
	if !hasAssertLine {
		t.Error("Expected assert line in output")
	}
	if !hasPipes {
		t.Error("Expected pipe characters in output")
	}
	if !hasValues {
		t.Error("Expected value displays in output")
	}
}

func TestVisualLayerArchitecture_PipeContinuity(t *testing.T) {
	formatter := NewVisualFormatter()
	
	// Create a scenario where pipes should continue across multiple layers
	positions := []ValuePosition{
		{Expression: "a", Value: "5", VisualPos: 0, Priority: 20, Depth: 0},
		{Expression: "b", Value: "verylongvalue", VisualPos: 2, Priority: 15, Depth: 0}, // Will be on layer 0
		{Expression: "c", Value: "10", VisualPos: 4, Priority: 10, Depth: 0}, // Conflicts with b, goes to layer 1
	}
	
	result := formatter.buildPowerAssertTreeWithLayers("a+b+c", positions)
	
	// Count pipe lines - should have continuity
	pipeLineCount := 0
	for _, line := range result {
		if strings.Contains(line, "|") {
			pipeLineCount++
		}
	}
	
	// Should have multiple pipe lines showing continuity
	if pipeLineCount < 1 {
		t.Errorf("Expected at least 1 pipe line for continuity, got %d", pipeLineCount)
	}
	
	// Check that all expected pipe positions appear in at least one pipe line
	expectedPipes := []int{0, 2, 4}
	for _, line := range result {
		if strings.Contains(line, "|") {
			for _, pos := range expectedPipes {
				if pos < len(line) && line[pos] != '|' {
					// This specific line might not have all pipes, but overall we should have continuity
					continue
				}
			}
		}
	}
}